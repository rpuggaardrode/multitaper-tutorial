<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Rasmus Puggaard-Rode">
<meta name="dcterms.date" content="2023-06-16">

<title>Generating and analyzing multitaper spectra in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Generating and analyzing multitaper spectra in R</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="http://rasmuspuggaard.wordpress.com">Rasmus Puggaard-Rode</a> </p>
  </div>
    <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Institute for Phonetics and Speech Processing, Ludwig Maximilian University of Munich
          </p>
      </div>
    </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 16, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="brief-introduction" class="level2">
<h2 class="anchored" data-anchor-id="brief-introduction">Brief introduction</h2>
<p>This is a tutorial showing how to generate multitaper spectra in R and how to compute their spectral moments and DCT coefficients. I will not go into a lot of technical detail about how they are computed; for more on this, see <span class="citation" data-cites="reidy2013">Reidy (<a href="#ref-reidy2013" role="doc-biblioref">2013</a>)</span> and <span class="citation" data-cites="reidy2015">Reidy (<a href="#ref-reidy2015" role="doc-biblioref">2015</a>)</span>.</p>
<p>By way of introduction, when linguists analyze speech data, we are very often interested in how much energy is found at different frequencies. This is not easy to spot from the waveform, so the signal is converted into spectrograms or spectral slices, usually generated using the fast Fourier transformation (FFT). As the name suggests, this method is <em>fast</em>.</p>
<p>FFT spectra are suitable for analyzing voiced portions of speech, but in both theory and practice they can be less suitable for analyzing voiceless portions of speech. This is because the Fourier basis is <em>periodic</em>, making the FFT inherently more suitable for periodic signals, such as voiced portions of speech, and less suitable for aperiodic signals, such as voiceless portions of speech.</p>
<p>Variance is reduced in multitaper spectral estimation, making multitaper spectra theoretically and practically and more suitable for voiceless portions of speech. <em>Theoretically</em>, because there is no strong assumption of periodicity in the underlying signal, and <em>practically</em>, because FFT spectra of voiceless speech are packed with unwanted noise, which is a major disadvantage if you want to use spectra (or numbers computed from spectra) as dependent variables in a statistical model.</p>
<p>We’ll be using the packages <code>rPraat</code>, <code>phonTools</code>, <code>seewave</code>, <code>multitaper</code>, and <code>emuR</code>, so make sure those are installed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="fu">c</span>(<span class="st">'rPraat'</span>, <span class="st">'phonTools'</span>, <span class="st">'seewave'</span>, <span class="st">'multitaper'</span>, <span class="st">'emuR'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="loading-and-preprocessing-sound-files" class="level2">
<h2 class="anchored" data-anchor-id="loading-and-preprocessing-sound-files">Loading and preprocessing sound files</h2>
<p>There are several functions for loading sound files into R, resulting in objects with different formats. I’ll use <code>snd.read()</code> from the package <code>rPraat</code> here, but you can use whichever method you prefer. The file contains a female Kmhmu’ speaker saying a single syllable [siːm]. It comes from <a href="https://osf.io/wv6qz">this OSF repository</a> (see <span class="citation" data-cites="kirby2022">Kirby, Pittayaporn, and Brunelle (<a href="#ref-kirby2022" role="doc-biblioref">2022</a>)</span>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rPraat)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>snd_obj <span class="ot">&lt;-</span> <span class="fu">snd.read</span>(<span class="st">'snd/1.wav'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>snd_obj</code> is an object of the type <code>Sound</code>, which R treats as a list containing a bunch of information about the sound file. The actual sound signal is stored in <code>snd_obj$sig</code>, time (in seconds) of each sample is given in <code>snd_obj$t</code>, and the sample rate of the file is given in <code>snd_obj$fs</code>. If we use the base R plotting function to produce a regular line plot of the signal, we get a waveform. I’ve added red lines indicating the location of the sibilant.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>sib_loc <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.075</span>, <span class="fl">0.21</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>snd_obj<span class="sc">$</span>t, <span class="at">y=</span>snd_obj<span class="sc">$</span>sig, <span class="at">type=</span><span class="st">'l'</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">'Time (s)'</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sib_loc, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Here’s a spectrogram of the sound, generated using the <code>spectrogram()</code> function from the <code>phonTools</code> package:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(phonTools)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">spectrogram</span>(snd_obj<span class="sc">$</span>sig[,<span class="dv">1</span>], <span class="at">fs=</span>snd_obj<span class="sc">$</span>fs, <span class="at">maxfreq=</span><span class="dv">8000</span>, </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>            <span class="at">colors=</span><span class="cn">FALSE</span>, <span class="at">dynamicrange=</span><span class="dv">60</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>sib_loc<span class="sc">*</span><span class="dv">1000</span>, <span class="at">col=</span><span class="st">'red'</span>, <span class="at">lwd=</span><span class="fl">2.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This sound file has a sample rate of 44.1 kHz, which is much more than we need for our purposes, so I’ll downsample it to 16 kHz using the <code>resamp()</code> function from the <code>seewave</code> package. This function takes the arguments <code>f</code> (the original sample rate) and <code>g</code> (the desired sample rate).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(seewave)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>sr <span class="ot">&lt;-</span> <span class="dv">16000</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>snd_16kHz <span class="ot">&lt;-</span> <span class="fu">resamp</span>(snd_obj<span class="sc">$</span>sig, <span class="at">f=</span>snd_obj<span class="sc">$</span>fs, <span class="at">g=</span>sr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, I’ll extract just those sound samples that belong to the sibilant in the object, and extract a 10 ms snippet from the middle of that.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>snd_sib <span class="ot">&lt;-</span> snd_16kHz[(sib_loc[<span class="dv">1</span>]<span class="sc">*</span>sr)<span class="sc">:</span>(sib_loc[<span class="dv">2</span>]<span class="sc">*</span>sr)]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>mid <span class="ot">&lt;-</span> <span class="fu">length</span>(snd_sib)<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>snd <span class="ot">&lt;-</span> snd_sib[(mid<span class="sc">-</span>(<span class="fl">0.005</span><span class="sc">*</span>sr))<span class="sc">:</span>(mid<span class="sc">+</span>(<span class="fl">0.005</span><span class="sc">*</span>sr))]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our 10 ms snippet <code>snd</code> looks like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(snd, <span class="at">type=</span><span class="st">'l'</span>, <span class="at">xlab=</span><span class="st">'Time (samples)'</span>, <span class="at">ylab=</span><span class="st">'Amplitude'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="generating-spectra" class="level2">
<h2 class="anchored" data-anchor-id="generating-spectra">Generating spectra</h2>
<p>First of all, for expository purposes, I’ll generate an FFT spectrum of our sound using the <code>spectralslice()</code> function in <code>phonTools</code>. The <code>fs</code> argument is the signal’s sample rate.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>fft <span class="ot">&lt;-</span> <span class="fu">spectralslice</span>(snd, <span class="at">fs=</span>sr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As you can see, it’s very noisy and jagged. I saved it in an object <code>fft</code> which is a matrix containing information about the energy distribution in dB by frequency:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(fft)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            hz        dB
[1,]   0.00000 -13.11734
[2,]  33.12629 -12.71219
[3,]  66.25259 -11.82737
[4,]  99.37888 -11.00038
[5,] 132.50518 -10.53785
[6,] 165.63147 -10.54571</code></pre>
</div>
</div>
<p>I’ll go ahead and convert that to a data frame, which will make our lives easier down the line.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>fft_df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(fft)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Multitaper spectra can be generated using the <code>spec.mtm()</code> function from the <code>multitaper</code> package. I set the arguments <code>nw</code>, a frequency bandwidth parameter, and <code>k</code>, the number of eigenspectra used to compute the final spectrum, following the suggestions by <span class="citation" data-cites="reidy2013">Reidy (<a href="#ref-reidy2013" role="doc-biblioref">2013</a>)</span>. The <code>spec.mtm()</code> defaults are <code>nw=4</code>, which is also what Reidy uses, and <code>k=7</code>, where Reidy uses <span class="math inline">\(K=2nW\)</span>, i.e.&nbsp;<code>k=8</code>. The <code>deltat</code> argument is the duration of each sample in the signal, i.e.&nbsp;1 divided by our sample rate.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(multitaper)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>mts <span class="ot">&lt;-</span> <span class="fu">spec.mtm</span>(snd, <span class="at">nw=</span><span class="dv">4</span>, <span class="at">k=</span><span class="dv">8</span>, <span class="at">deltat=</span><span class="dv">1</span><span class="sc">/</span>sr, </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>, <span class="at">ylab=</span><span class="st">''</span>, <span class="at">main=</span><span class="st">''</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The multitaper spectrum has a much more stable shape than the FFT spectrum.</p>
<p>Since we already converted the FFT spectrum to a data frame, that already has the format we need for computing things like spectral moments and DCT coefficients. The R object containing the multitaper spectrum is rather more complicated:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         Length Class  Mode     
origin.n   1    -none- numeric  
method     1    -none- character
pad        1    -none- numeric  
spec     257    -none- numeric  
freq     257    -none- numeric  
series     1    -none- character
adaptive   1    -none- logical  
mtm       14    -none- list     </code></pre>
</div>
</div>
<p>The information that we have in the corresponding FFT spectrum data frame <code>fft_df</code> is what’s stored in <code>mts$spec</code> and <code>mts$freq</code>. Be aware, however, that we can’t just grab those from the <code>mts</code> object and assume all is well. If we plot them directly, we get this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>mts<span class="sc">$</span>freq, <span class="at">y=</span>mts<span class="sc">$</span>spec, <span class="at">type=</span><span class="st">'l'</span>,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>, <span class="at">ylab=</span><span class="st">"What's this?"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>It doesn’t look at all like what we saw above. This is because energy is in the <span class="math inline">\(W/m^2\)</span> scale and not the decibel scale. Taking the natural log of this number will give us a spectrum that’s visually identical to what the plotting function of <code>multitaper</code> produces.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>mts<span class="sc">$</span>freq, <span class="at">y=</span><span class="fu">log</span>(mts<span class="sc">$</span>spec), <span class="at">type=</span><span class="st">'l'</span>,</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">'Frequency (Hz)'</span>, <span class="at">ylab=</span><span class="st">''</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>I usually standardize spectra before analyzing them statistically, so the exact scale is much less important than the curve shape. For now, let’s save a logged version of the multitaper spectrum in a data frame like we did with the FFT spectrum.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>mts_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">hz =</span> mts<span class="sc">$</span>freq,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">energy =</span> <span class="fu">log</span>(mts<span class="sc">$</span>spec))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="computing-spectral-moments" class="level2">
<h2 class="anchored" data-anchor-id="computing-spectral-moments">Computing spectral moments</h2>
<p>We calculate spectral moments using the function <code>moments()</code> from the package <code>emuR</code>. It takes the arguments <code>count</code> which is our energy dimension (in whatever scale) and <code>x</code> which is our frequency dimension (in whatever scale). <code>moments()</code> simply returns a vector with four numbers, corresponding to the first four spectral moments, i.e.&nbsp;mean (AKA center of gravity), variance, skew, and kurtosis. Phonetics studies usually report standard deviation rather than variance, because standard deviation is on the easily interpretable Hz scale while variance is on the <span class="math inline">\(Hz^2\)</span> scale. For this reason, we replace the second number of the vector with its square root. We also have to set <code>minval=TRUE</code> because our energy scale contains negative values; if we don’t do this, the results would essentially be as if we had flipped the spectrum upside down.</p>
<p>Let’s try to do this for our FFT spectrum first.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emuR)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>fft_moments <span class="ot">&lt;-</span> <span class="fu">moments</span>(fft_df<span class="sc">$</span>dB, fft_df<span class="sc">$</span>hz, <span class="at">minval=</span><span class="cn">TRUE</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>fft_moments[<span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(fft_moments[<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And we’ll repeat that for our multitaper spectrum.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>mts_moments <span class="ot">&lt;-</span> <span class="fu">moments</span>(mts_df<span class="sc">$</span>energy, mts_df<span class="sc">$</span>hz, <span class="at">minval=</span><span class="cn">TRUE</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>mts_moments[<span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(mts_moments[<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s compare the two results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fft_moments</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4448.8620672 2263.6365777   -0.3434053   -0.9921930</code></pre>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>mts_moments</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5285.5510979 1923.2638132   -0.9888046    0.4330012</code></pre>
</div>
</div>
<p>The standard deviations are not so different, but there’s a very significant 500+ Hz difference in center of gravity, and notable differences in skewness and kurtosis as well. The take home message is that the method of spectral estimation <em>matters</em>.</p>
</section>
<section id="computing-dct-coefficients" class="level2">
<h2 class="anchored" data-anchor-id="computing-dct-coefficients">Computing DCT coefficients</h2>
<p>Another way of summarizing spectral shape is using the coefficients of a discrete cosine transformation of the spectrum. Usually the first four coefficients are reported. This is also implemented in the <code>emuR</code> package, in the <code>dct()</code> function. <code>dct()</code> takes the arguments <code>data</code> which is our energy dimension, and <code>m</code> which is the number of coefficients to return. Since DCT coefficients only say something about the shape of a curve, the function doesn’t actually care about the frequency dimension. If we set <code>m=3</code>, the function returns a vector of four numbers, corresponding to k0, k1, k2, and k3, which reflect mean amplitude, linear slope, curvature, and strength at higher frequencies, respectively.</p>
<p>For our FFT spectrum, it looks like this.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>fft_dct <span class="ot">&lt;-</span> <span class="fu">dct</span>(fft_df<span class="sc">$</span>dB, <span class="at">m=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And for our multitaper spectrum, it looks like this.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>mts_dct <span class="ot">&lt;-</span> <span class="fu">dct</span>(mts_df<span class="sc">$</span>energy, <span class="at">m=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These are the results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>fft_dct</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -17.3128029  -5.1061743  -0.2610576   2.3781157</code></pre>
</div>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>mts_dct</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -28.54994097  -1.43138455   0.05025888   0.69589289</code></pre>
</div>
</div>
<p>Here, as well, different methods of spectral estimation have serious implications for the results.</p>
</section>
<section id="bulk-processing" class="level2">
<h2 class="anchored" data-anchor-id="bulk-processing">Bulk processing</h2>
<p>Usually we won’t want to compute and analyze a single spectrum. If we have a research question, we’ll probably want to do this in bulk by looking at how the spectrum changes over time, or we’ll have multiple tokens of some consonant, multiple sound files, etc. Here I’ll just give two examples of how spectra can be computed and analyzed in bulk. Hopefully these examples can also be helpful for other use cases.</p>
<p>If we wanted to look at spectral dynamics over time in our fricative <code>snd_sib</code> by computing, say, spectral moments from 10 equidistant multitaper spectra of 10 ms, we could then do the following.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">#number of samples in 10 ms</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>cs <span class="ot">&lt;-</span> sr<span class="sc">/</span><span class="dv">100</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co">#number of samples in the fricative</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>n_samp <span class="ot">&lt;-</span> <span class="fu">length</span>(snd_sib)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co">#our number of equidistant spectra</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>steps <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co">#create vector of start times for the spectra</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>t1 <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">1</span>, n_samp<span class="sc">-</span>cs, <span class="at">length.out=</span>steps)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">#create vector of end times for the spectra</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>t2 <span class="ot">&lt;-</span> <span class="fu">seq</span>(cs, n_samp, <span class="at">length.out=</span>steps)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty data frame with nrow=steps</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>mom <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">step =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, steps),</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>                  <span class="at">cog =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, steps),</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>                  <span class="at">sd =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, steps),</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>                  <span class="at">skew =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, steps),</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>                  <span class="at">kurtosis =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, steps))</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>steps) {</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">#create ith 10 ms snippet</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>  tmp <span class="ot">&lt;-</span> snd_sib[t1[i]<span class="sc">:</span>t2[i]]</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute multitaper spectrum without plotting</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>  tmp_mts <span class="ot">&lt;-</span> <span class="fu">spec.mtm</span>(tmp, <span class="at">nw=</span><span class="dv">4</span>, <span class="at">k=</span><span class="dv">8</span>, <span class="at">deltat=</span><span class="dv">1</span><span class="sc">/</span>sr, <span class="at">plot=</span><span class="cn">FALSE</span>)</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute spectral moments</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>  tmp_mom <span class="ot">&lt;-</span> <span class="fu">moments</span>(<span class="at">count=</span><span class="fu">log</span>(tmp_mts<span class="sc">$</span>spec), <span class="at">x=</span>tmp_mts<span class="sc">$</span>freq, <span class="at">minval=</span><span class="cn">TRUE</span>)</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>  mom<span class="sc">$</span>step[i] <span class="ot">&lt;-</span> i</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>  mom<span class="sc">$</span>cog[i] <span class="ot">&lt;-</span> tmp_mom[<span class="dv">1</span>]</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute standard deviation from variance</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>  mom<span class="sc">$</span>sd[i] <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(tmp_mom[<span class="dv">2</span>])</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>  mom<span class="sc">$</span>skew[i] <span class="ot">&lt;-</span> tmp_mom[<span class="dv">3</span>]</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>  mom<span class="sc">$</span>kurtosis[i] <span class="ot">&lt;-</span> tmp_mom[<span class="dv">4</span>]</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This results in a data frame with time series for each spectral moments. It looks like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>mom</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   step      cog       sd       skew    kurtosis
1     1 4571.408 2166.009 -0.6673762 -0.77891571
2     2 4783.664 1971.263 -0.6685795 -0.21745276
3     3 5023.175 1944.880 -0.8370027  0.12011007
4     4 5216.251 1837.283 -0.8268089  0.38115373
5     5 5164.443 2035.474 -0.8708143 -0.02836778
6     6 5060.708 2107.689 -0.8178161 -0.23411048
7     7 5040.835 2154.075 -0.8062055 -0.30271009
8     8 4844.621 2406.120 -0.8944617 -0.49022781
9     9 5159.789 2039.067 -0.9876985  0.16785162
10   10 4396.522 2413.308 -0.5145603 -0.95902483</code></pre>
</div>
</div>
<p>(Hint: If you were to repeat this with FFT spectra, you’d see that the variation between adjacent spectra would be much larger).</p>
<p>Imagine that we had a sound file with a bunch of sibilants and for each of them we want to compute the first four DCT coefficients of multitaper spectra computed around the 10 ms midpoint. Here’s an example of a sound file with 5 [s]es and a TextGrid that marks their locations. (I plot this using a home cooked function <code>plot_tg_tier</code>, which you can find in the source code for this tutorial.)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_tg_tier</span>(<span class="at">sound=</span><span class="st">'snd/5.wav'</span>, <span class="at">textgrid=</span><span class="st">'snd/5.TextGrid'</span>, <span class="at">tier=</span><span class="st">'sib'</span>,</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">max_freq=</span><span class="dv">8000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In order to do this, we’d first load in the TextGrid using the function <code>tg.read()</code> from the <code>rPraat</code> package.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>tg <span class="ot">&lt;-</span> <span class="fu">tg.read</span>(<span class="st">'snd/5.TextGrid'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This TextGrid has just one tier <code>sib</code>, and the resulting R object contains information about the start and end times of each interval and the labels in them.</p>
<p>The rest of the operation could look like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">#find the intervals with label 's'</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>s_int <span class="ot">&lt;-</span> <span class="fu">which</span>(tg<span class="sc">$</span>sib<span class="sc">$</span>label <span class="sc">==</span> <span class="st">'s'</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">#how many intervals?</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>ns <span class="ot">&lt;-</span> <span class="fu">length</span>(s_int)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">#create empty data frame with nrow=ns</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>dct_coef <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">id =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ns),</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>                       <span class="at">t1 =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ns),</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>                       <span class="at">t2 =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ns),</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>                       <span class="at">k0 =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ns),</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>                       <span class="at">k1 =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ns),</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>                       <span class="at">k2 =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ns),</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>                       <span class="at">k3 =</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ns))</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>ns) {</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">#number of the ith interval with label 's'</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>  int <span class="ot">&lt;-</span> s_int[i]</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">#start time of the ith interval with label 's'</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>  t1 <span class="ot">&lt;-</span> tg<span class="sc">$</span>sib<span class="sc">$</span>t1[int]</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">#end time of the ith interval with label 's'</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>  t2 <span class="ot">&lt;-</span> tg<span class="sc">$</span>sib<span class="sc">$</span>t2[int]</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">#mid point of the interval</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>  midpoint <span class="ot">&lt;-</span> t1 <span class="sc">+</span> (t2<span class="sc">-</span>t1) <span class="sc">/</span> <span class="dv">2</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">#read in 10 ms snippet from sound file around the midpoint</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">#of the ith interval with label 's'</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>  tmp <span class="ot">&lt;-</span> <span class="fu">snd.read</span>(<span class="st">'snd/5.wav'</span>, </span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>                  <span class="at">from=</span>midpoint<span class="fl">-0.005</span>, <span class="at">to=</span>midpoint<span class="fl">+0.005</span>, </span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>                  <span class="at">units=</span><span class="st">'seconds'</span>)</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">#downsample to 16 kHz as shown above</span></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>  tmp_16kHz <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(<span class="fu">resamp</span>(tmp<span class="sc">$</span>sig, <span class="at">f=</span>tmp<span class="sc">$</span>fs, <span class="at">g=</span>sr))</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">#compute multitaper spectrum without plotting</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>  tmp_mts <span class="ot">&lt;-</span> <span class="fu">spec.mtm</span>(tmp_16kHz, <span class="at">nw=</span><span class="dv">4</span>, <span class="at">k=</span><span class="dv">8</span>, <span class="at">deltat=</span><span class="dv">1</span><span class="sc">/</span>sr, <span class="at">plot=</span><span class="cn">FALSE</span>)</span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">#get 4 DCT coefficients as shown above</span></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>  tmp_dct <span class="ot">&lt;-</span> <span class="fu">dct</span>(<span class="fu">log</span>(tmp_mts<span class="sc">$</span>spec), <span class="at">m=</span><span class="dv">3</span>)</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">#fill in data frame</span></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>  dct_coef<span class="sc">$</span>id[i] <span class="ot">&lt;-</span> i</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>  dct_coef<span class="sc">$</span>t1[i] <span class="ot">&lt;-</span> t1</span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>  dct_coef<span class="sc">$</span>t2[i] <span class="ot">&lt;-</span> t2</span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>  dct_coef<span class="sc">$</span>k0[i] <span class="ot">&lt;-</span> tmp_dct[<span class="dv">1</span>]</span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>  dct_coef<span class="sc">$</span>k1[i] <span class="ot">&lt;-</span> tmp_dct[<span class="dv">2</span>]</span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>  dct_coef<span class="sc">$</span>k2[i] <span class="ot">&lt;-</span> tmp_dct[<span class="dv">3</span>]</span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>  dct_coef<span class="sc">$</span>k3[i] <span class="ot">&lt;-</span> tmp_dct[<span class="dv">4</span>]</span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now have a data frame <code>dct_coef</code> with spectral DCT coefficients computed from the midpoint of each sibilant:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>dct_coef</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id        t1        t2        k0        k1        k2          k3
1  1 0.1142821 0.2950639 -26.54519 -1.529873 0.4460807  0.30874918
2  2 0.8182295 0.9670684 -26.01753 -1.501038 0.3764371 -0.03228430
3  3 1.7678831 1.8943365 -26.36810 -1.606486 0.3366901 -0.07079519
4  4 2.5671831 2.7023670 -26.28169 -1.633347 0.5080955 -0.37781924
5  5 3.2914200 3.4253128 -27.27152 -1.289093 0.3231615 -0.10775605</code></pre>
</div>
</div>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-kirby2022" class="csl-entry" role="listitem">
Kirby, James, Pittayawat Pittayaporn, and Marc Brunelle. 2022. <span>“Transphonologization of Onset Voicing: Revisiting Northern and Eastern Kmhmu<span>’</span>.”</span> <em>Phonetica</em> 79 (6): 591–629. <a href="https://doi.org/10.1515/phon-2022-0029">https://doi.org/10.1515/phon-2022-0029</a>.
</div>
<div id="ref-reidy2013" class="csl-entry" role="listitem">
Reidy, Patrick. 2013. <span>“An Introduction to Random Processes for the Spectral Analysis of Speech Data.”</span> <em>Ohio State University Working Papers in Linguistics</em> 60: 67–116.
</div>
<div id="ref-reidy2015" class="csl-entry" role="listitem">
———. 2015. <span>“A Comparison of Spectral Estimation Methods for the Analysis of Sibilant Fricatives.”</span> <em>JASA Express Letters</em> 137 (4): 248–54. <a href="https://doi.org/10.1121/1.4915064">https://doi.org/10.1121/1.4915064</a>.
</div>
</div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div>CC-BY-SA 4.0</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>